import { useState, useEffect, useCallback, useRef } from 'react';\n\n/**\n * Hook for debouncing values\n */\nexport function useDebounce<T>(value: T, delay: number): T {\n  const [debouncedValue, setDebouncedValue] = useState<T>(value);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n\n/**\n * Hook for debouncing callbacks\n */\nexport function useDebouncedCallback<T extends (...args: any[]) => any>(\n  callback: T,\n  delay: number,\n  deps?: React.DependencyList\n): T {\n  const callbackRef = useRef(callback);\n  const timeoutRef = useRef<NodeJS.Timeout>();\n\n  // Update callback ref when dependencies change\n  useEffect(() => {\n    callbackRef.current = callback;\n  }, deps ? [callback, ...deps] : [callback]);\n\n  const debouncedCallback = useCallback(\n    ((...args: Parameters<T>) => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n\n      timeoutRef.current = setTimeout(() => {\n        callbackRef.current(...args);\n      }, delay);\n    }) as T,\n    [delay]\n  );\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, []);\n\n  return debouncedCallback;\n}\n\n/**\n * Hook for throttling values\n */\nexport function useThrottle<T>(value: T, limit: number): T {\n  const [throttledValue, setThrottledValue] = useState<T>(value);\n  const lastRan = useRef<number>(Date.now());\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      if (Date.now() - lastRan.current >= limit) {\n        setThrottledValue(value);\n        lastRan.current = Date.now();\n      }\n    }, limit - (Date.now() - lastRan.current));\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, limit]);\n\n  return throttledValue;\n}\n\n/**\n * Hook for throttling callbacks\n */\nexport function useThrottledCallback<T extends (...args: any[]) => any>(\n  callback: T,\n  limit: number,\n  deps?: React.DependencyList\n): T {\n  const callbackRef = useRef(callback);\n  const lastRan = useRef<number>(0);\n\n  // Update callback ref when dependencies change\n  useEffect(() => {\n    callbackRef.current = callback;\n  }, deps ? [callback, ...deps] : [callback]);\n\n  const throttledCallback = useCallback(\n    ((...args: Parameters<T>) => {\n      if (Date.now() - lastRan.current >= limit) {\n        callbackRef.current(...args);\n        lastRan.current = Date.now();\n      }\n    }) as T,\n    [limit]\n  );\n\n  return throttledCallback;\n}\n\n/**\n * Hook for delayed execution\n */\nexport function useDelayedExecution(\n  callback: () => void,\n  delay: number,\n  dependencies: React.DependencyList\n) {\n  const timeoutRef = useRef<NodeJS.Timeout>();\n\n  useEffect(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n\n    timeoutRef.current = setTimeout(callback, delay);\n\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, dependencies);\n\n  const cancel = useCallback(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n  }, []);\n\n  return { cancel };\n}\n\n/**\n * Hook for batching state updates\n */\nexport function useBatchedUpdates<T>(\n  initialValue: T,\n  batchDelay: number = 100\n) {\n  const [value, setValue] = useState<T>(initialValue);\n  const [pendingValue, setPendingValue] = useState<T>(initialValue);\n  const timeoutRef = useRef<NodeJS.Timeout>();\n\n  const batchedSetValue = useCallback((newValue: T | ((prev: T) => T)) => {\n    const resolvedValue = typeof newValue === 'function' \n      ? (newValue as (prev: T) => T)(pendingValue)\n      : newValue;\n    \n    setPendingValue(resolvedValue);\n\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n\n    timeoutRef.current = setTimeout(() => {\n      setValue(resolvedValue);\n    }, batchDelay);\n  }, [pendingValue, batchDelay]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, []);\n\n  return [value, batchedSetValue] as const;\n}"