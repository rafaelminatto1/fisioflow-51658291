import { useCallback } from 'react';\nimport { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';\nimport { PaymentService } from '@/lib/services/PaymentService';\nimport type { CreatePaymentData, Payment } from '@/types/agenda';\n\n// Query keys for payments\nexport const paymentKeys = {\n  all: ['payments'] as const,\n  byId: (id: string) => [...paymentKeys.all, 'byId', id] as const,\n  byPatient: (patientId: string) => [...paymentKeys.all, 'byPatient', patientId] as const,\n  byAppointment: (appointmentId: string) => [...paymentKeys.all, 'byAppointment', appointmentId] as const,\n};\n\n/**\n * Hook for getting patient payments\n */\nexport function usePatientPayments(patientId: string | undefined) {\n  return useQuery({\n    queryKey: paymentKeys.byPatient(patientId || ''),\n    queryFn: () => PaymentService.getPatientPayments(patientId!),\n    enabled: !!patientId,\n    staleTime: 2 * 60 * 1000, // 2 minutes\n  });\n}\n\n/**\n * Hook for getting appointment payments\n */\nexport function useAppointmentPayments(appointmentId: string | undefined) {\n  return useQuery({\n    queryKey: paymentKeys.byAppointment(appointmentId || ''),\n    queryFn: () => PaymentService.getAppointmentPayments(appointmentId!),\n    enabled: !!appointmentId,\n    staleTime: 2 * 60 * 1000, // 2 minutes\n  });\n}\n\n/**\n * Hook for creating payments\n */\nexport function useCreatePayment() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (data: CreatePaymentData) => PaymentService.createPayment(data),\n    \n    onSuccess: (createdPayment) => {\n      // Invalidate related queries\n      queryClient.invalidateQueries({ queryKey: paymentKeys.byPatient(createdPayment.patient_id) });\n      queryClient.invalidateQueries({ queryKey: paymentKeys.byAppointment(createdPayment.appointment_id) });\n      queryClient.invalidateQueries({ queryKey: paymentKeys.all });\n    },\n  });\n}\n\n/**\n * Hook for updating payments\n */\nexport function useUpdatePayment() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: ({ paymentId, updates }: { paymentId: string; updates: Partial<Payment> }) =>\n      PaymentService.updatePayment(paymentId, updates),\n    \n    onSuccess: (updatedPayment) => {\n      // Update cache\n      queryClient.setQueryData(paymentKeys.byId(updatedPayment.id), updatedPayment);\n      \n      // Invalidate related queries\n      queryClient.invalidateQueries({ queryKey: paymentKeys.byPatient(updatedPayment.patient_id) });\n      queryClient.invalidateQueries({ queryKey: paymentKeys.byAppointment(updatedPayment.appointment_id) });\n    },\n  });\n}\n\n/**\n * Hook for deleting payments\n */\nexport function useDeletePayment() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (paymentId: string) => PaymentService.deletePayment(paymentId),\n    \n    onSuccess: (_, paymentId) => {\n      // Remove from cache\n      queryClient.removeQueries({ queryKey: paymentKeys.byId(paymentId) });\n      \n      // Invalidate all payment queries\n      queryClient.invalidateQueries({ queryKey: paymentKeys.all });\n    },\n  });\n}\n\n/**\n * Utility hook for invalidating payment queries\n */\nexport function useInvalidatePayments() {\n  const queryClient = useQueryClient();\n\n  return useCallback((scope?: 'all' | string) => {\n    if (scope === 'all') {\n      queryClient.invalidateQueries({ queryKey: paymentKeys.all });\n    } else if (scope) {\n      // Invalidate specific patient payments\n      queryClient.invalidateQueries({ queryKey: paymentKeys.byPatient(scope) });\n    } else {\n      // Invalidate everything\n      queryClient.invalidateQueries({ queryKey: paymentKeys.all });\n    }\n  }, [queryClient]);\n}"