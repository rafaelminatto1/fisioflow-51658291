import { useState, useEffect, useCallback, useMemo } from 'react';\n\ninterface VirtualizationOptions {\n  itemHeight: number;\n  containerHeight: number;\n  overscan?: number; // Number of items to render outside visible area\n  scrollElement?: HTMLElement | null;\n}\n\ninterface VirtualItem {\n  index: number;\n  start: number;\n  end: number;\n}\n\nexport function useVirtualization<T>(\n  items: T[],\n  options: VirtualizationOptions\n) {\n  const { itemHeight, containerHeight, overscan = 5, scrollElement } = options;\n  \n  const [scrollTop, setScrollTop] = useState(0);\n  const [isScrolling, setIsScrolling] = useState(false);\n\n  // Calculate visible range\n  const visibleRange = useMemo(() => {\n    const visibleStart = Math.floor(scrollTop / itemHeight);\n    const visibleEnd = Math.min(\n      visibleStart + Math.ceil(containerHeight / itemHeight),\n      items.length - 1\n    );\n\n    return {\n      start: Math.max(0, visibleStart - overscan),\n      end: Math.min(items.length - 1, visibleEnd + overscan)\n    };\n  }, [scrollTop, itemHeight, containerHeight, overscan, items.length]);\n\n  // Calculate virtual items\n  const virtualItems = useMemo((): VirtualItem[] => {\n    const items = [];\n    for (let i = visibleRange.start; i <= visibleRange.end; i++) {\n      items.push({\n        index: i,\n        start: i * itemHeight,\n        end: (i + 1) * itemHeight\n      });\n    }\n    return items;\n  }, [visibleRange, itemHeight]);\n\n  // Total height of all items\n  const totalHeight = items.length * itemHeight;\n\n  // Offset for visible items\n  const offsetY = visibleRange.start * itemHeight;\n\n  // Handle scroll events\n  const handleScroll = useCallback((event: Event) => {\n    const target = event.target as HTMLElement;\n    setScrollTop(target.scrollTop);\n    \n    setIsScrolling(true);\n    \n    // Debounce scrolling state\n    const timeoutId = setTimeout(() => {\n      setIsScrolling(false);\n    }, 150);\n\n    return () => clearTimeout(timeoutId);\n  }, []);\n\n  // Attach scroll listener\n  useEffect(() => {\n    const element = scrollElement || window;\n    element.addEventListener('scroll', handleScroll, { passive: true });\n    \n    return () => {\n      element.removeEventListener('scroll', handleScroll);\n    };\n  }, [scrollElement, handleScroll]);\n\n  // Scroll to specific item\n  const scrollToItem = useCallback((index: number, align: 'start' | 'center' | 'end' = 'start') => {\n    if (!scrollElement) return;\n\n    const itemTop = index * itemHeight;\n    let scrollTop = itemTop;\n\n    if (align === 'center') {\n      scrollTop = itemTop - containerHeight / 2 + itemHeight / 2;\n    } else if (align === 'end') {\n      scrollTop = itemTop - containerHeight + itemHeight;\n    }\n\n    scrollElement.scrollTo({\n      top: Math.max(0, Math.min(scrollTop, totalHeight - containerHeight)),\n      behavior: 'smooth'\n    });\n  }, [scrollElement, itemHeight, containerHeight, totalHeight]);\n\n  return {\n    virtualItems,\n    totalHeight,\n    offsetY,\n    isScrolling,\n    scrollToItem,\n    visibleRange\n  };\n}\n\n// Hook for infinite scrolling\nexport function useInfiniteScroll<T>(\n  items: T[],\n  loadMore: () => Promise<void>,\n  options: {\n    threshold?: number; // Distance from bottom to trigger load\n    hasMore: boolean;\n    isLoading: boolean;\n  }\n) {\n  const { threshold = 200, hasMore, isLoading } = options;\n  const [scrollElement, setScrollElement] = useState<HTMLElement | null>(null);\n\n  const handleScroll = useCallback(() => {\n    if (!scrollElement || isLoading || !hasMore) return;\n\n    const { scrollTop, scrollHeight, clientHeight } = scrollElement;\n    const distanceFromBottom = scrollHeight - scrollTop - clientHeight;\n\n    if (distanceFromBottom < threshold) {\n      loadMore();\n    }\n  }, [scrollElement, isLoading, hasMore, threshold, loadMore]);\n\n  useEffect(() => {\n    if (!scrollElement) return;\n\n    scrollElement.addEventListener('scroll', handleScroll, { passive: true });\n    return () => scrollElement.removeEventListener('scroll', handleScroll);\n  }, [scrollElement, handleScroll]);\n\n  return {\n    setScrollElement,\n    scrollElement\n  };\n}\n\n// Hook for optimized list rendering with memoization\nexport function useOptimizedList<T>(\n  items: T[],\n  keyExtractor: (item: T, index: number) => string,\n  renderItem: (item: T, index: number) => React.ReactNode,\n  options?: {\n    chunkSize?: number;\n    enableVirtualization?: boolean;\n    itemHeight?: number;\n    containerHeight?: number;\n  }\n) {\n  const {\n    chunkSize = 50,\n    enableVirtualization = false,\n    itemHeight = 60,\n    containerHeight = 400\n  } = options || {};\n\n  const [visibleChunks, setVisibleChunks] = useState(1);\n  const [scrollElement, setScrollElement] = useState<HTMLElement | null>(null);\n\n  // Memoized rendered items\n  const renderedItems = useMemo(() => {\n    const itemsToRender = enableVirtualization \n      ? items \n      : items.slice(0, visibleChunks * chunkSize);\n\n    return itemsToRender.map((item, index) => ({\n      key: keyExtractor(item, index),\n      element: renderItem(item, index),\n      item,\n      index\n    }));\n  }, [items, visibleChunks, chunkSize, enableVirtualization, keyExtractor, renderItem]);\n\n  // Virtualization (if enabled)\n  const virtualization = useVirtualization(\n    items,\n    {\n      itemHeight,\n      containerHeight,\n      scrollElement: enableVirtualization ? scrollElement : null\n    }\n  );\n\n  // Load more chunks on scroll (if not using virtualization)\n  const handleScroll = useCallback(() => {\n    if (!scrollElement || enableVirtualization) return;\n\n    const { scrollTop, scrollHeight, clientHeight } = scrollElement;\n    const scrollPercentage = (scrollTop + clientHeight) / scrollHeight;\n\n    if (scrollPercentage > 0.8 && visibleChunks * chunkSize < items.length) {\n      setVisibleChunks(prev => prev + 1);\n    }\n  }, [scrollElement, enableVirtualization, visibleChunks, chunkSize, items.length]);\n\n  useEffect(() => {\n    if (!scrollElement || enableVirtualization) return;\n\n    scrollElement.addEventListener('scroll', handleScroll, { passive: true });\n    return () => scrollElement.removeEventListener('scroll', handleScroll);\n  }, [scrollElement, enableVirtualization, handleScroll]);\n\n  // Reset chunks when items change\n  useEffect(() => {\n    setVisibleChunks(1);\n  }, [items.length]);\n\n  return {\n    renderedItems: enableVirtualization \n      ? virtualization.virtualItems.map(vItem => renderedItems[vItem.index]).filter(Boolean)\n      : renderedItems,\n    setScrollElement,\n    virtualization: enableVirtualization ? virtualization : null,\n    hasMore: !enableVirtualization && visibleChunks * chunkSize < items.length,\n    loadedCount: enableVirtualization ? items.length : Math.min(visibleChunks * chunkSize, items.length)\n  };\n}\n\n// Performance monitoring hook\nexport function usePerformanceMonitor(name: string) {\n  const [metrics, setMetrics] = useState<{\n    renderTime: number;\n    renderCount: number;\n    averageRenderTime: number;\n  }>({ renderTime: 0, renderCount: 0, averageRenderTime: 0 });\n\n  const startTime = useMemo(() => performance.now(), []);\n\n  useEffect(() => {\n    const endTime = performance.now();\n    const renderTime = endTime - startTime;\n\n    setMetrics(prev => {\n      const newRenderCount = prev.renderCount + 1;\n      const totalTime = prev.averageRenderTime * prev.renderCount + renderTime;\n      const newAverageRenderTime = totalTime / newRenderCount;\n\n      return {\n        renderTime,\n        renderCount: newRenderCount,\n        averageRenderTime: newAverageRenderTime\n      };\n    });\n\n    // Log performance in development\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`[Performance] ${name}: ${renderTime.toFixed(2)}ms`);\n    }\n  });\n\n  return metrics;\n}"